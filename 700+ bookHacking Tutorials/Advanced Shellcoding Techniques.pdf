%PDF-1.3
1 0 obj
<<
/CreationDate(D:20160204102502)
/Title()
/Author(PDFZilla)
/Keywords(PDFZilla,Zilla PDF)
/Producer(PDFZilla - Zilla TXT To PDF Converter)
>>
endobj
5 0 obj
[
750 750 278 278 355 556 556 889 667 190 333 333 389 584 278 333 
278 278 556 556 556 556 556 556 556 556 556 556 278 278 584 584 
584 556 1015 667 667 722 722 667 610 778 722 278 500 667 556 832 
722 778 667 778 722 667 610 722 667 944 667 667 610 278 278 278 
469 556 333 556 556 500 556 556 278 556 556 222 222 500 222 832 
556 556 556 556 333 500 278 556 500 722 500 500 500 334 260 334 
584 750 556 750 222 556 333 1000 556 556 333 1000 667 333 1000 750 
610 750 750 222 222 333 333 350 556 1000 333 1000 500 333 944 750 
500 667 278 333 556 556 556 556 260 556 333 736 370 556 584 333 
736 552 400 549 333 333 333 576 537 333 333 333 365 556 834 834 
834 610 667 667 667 667 667 667 1000 722 667 667 667 667 278 278 
278 278 722 722 778 778 778 778 778 584 778 722 722 722 722 667 
667 610 556 556 556 556 556 556 889 500 556 556 556 556 278 278 
278 278 556 556 556 556 556 556 556 549 610 556 556 556 556 500 
556 500 
]
endobj
6 0 obj
<<
/Type/FontDescriptor
/FontName/Arial
/Ascent 905
/Descent -212
/ItalicAngle 0
/CapHeight 905
/Flags 32
/FontBBox[0 0 0 0]
>>
endobj
7 0 obj
<<
/Type/Font
/Subtype/TrueType
/Name/F0
/BaseFont/Arial
/Encoding/WinAnsiEncoding
/FirstChar 30
/LastChar 255
/Widths 5 0 R
/FontDescriptor 6 0 R
>>
endobj
8 0 obj
<<
/Length 6218
>>
stream
BT
/F0 10 Tf
0 0 0 rg
28.346 804.491 Td
(  ***********************************************) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 790.318 Td
(     *                                             *) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 776.144 Td
(     * Advanced Shellcoding Techniques - by Darawk *) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 761.971 Td
(     *                                             *) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 747.798 Td
(     ***********************************************) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 733.625 Td
(--------------------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 719.451 Td
(----------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 705.278 Td
( ///////////*1000+ HACKING TRICKS & TUTORIALS - ebook By Mukesh Bhardwaj Blogger  - Paid Version - only @ ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 691.105 Td
(TekGyd | itechhacks | Mukeshtricks4u*///////) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 676.932 Td
(--------------------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 662.759 Td
(----------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 648.585 Td
(Introduction) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 634.412 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 620.239 Td
(This paper assumes a working knowledge of basic shellcoding techniques, and x86 assembly, I will not rehash ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 606.066 Td
(these in this paper.  I hope to teach you some of the lesser known shellcoding techniques that I have picked ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 591.892 Td
(up, which will allow you to write smaller and better shellcodes.  I do not claim to have invented any of these) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 577.719 Td
(techniques, except for the one that uses the div instruction.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 563.546 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 549.373 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 535.199 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 521.026 Td
(The multiplicity of mul) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 506.853 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 492.68 Td
(This technique was originally developed by Sorbo of darkircop.net.  The mul instruction may, on the surface, ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 478.507 Td
(seem mundane, and it's purpose obvious.  However, when faced with the difficult challenge of shrinking your ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 464.333 Td
(shellcode, it proves to be quite useful.  First some background information on the mul instruction itself.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 450.16 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 435.987 Td
(mul performs an unsigned multiply of two integers.  It takes only one operand, the other is implicitly ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 421.814 Td
(specified by the %eax register.  So, a  common mul instruction might look something like this:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 407.64 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 393.467 Td
(movl $0x0a,%eax) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 379.294 Td
(mul $0x0a) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 365.121 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 350.948 Td
(This would multiply the value stored in %eax by the operand of mul, which in this case would be 10*10.  The ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 336.774 Td
(result is then implicitly stored in EDX:EAX.  The result is stored over a span of two registers because it has) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 322.601 Td
(the potential to be considerably larger than the previous value, possibly exceeding the capacity of a single ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 308.428 Td
(register\(this is also how floating points are stored in some cases, as an interesting sidenote\).) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 294.255 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 280.081 Td
(So, now comes the ever-important question.  How can we use these attributes to our advantage when writing ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 265.908 Td
(shellcode?  Well, let's think for a second, the instruction takes only one operand, therefore, since it is a ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 251.735 Td
(very common instruction, it will generate only two bytes in our final shellcode.  It multiplies whatever is ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 237.562 Td
(passed to it by the value stored in %eax, and stores the value in both %edx and %eax, completely overwriting ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 223.388 Td
(the contents of both registers, regardless of whether it is necessary to do so, in order to store the result ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 209.215 Td
(of the multiplication.  Let's put on our mathematician hats for a second, and consider this, what is the only ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 195.042 Td
(possible result of a multiplication by 0?  The answer, as you may have guessed, is 0.  I think it's about time) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 180.869 Td
(for some example code, so here it is:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 166.696 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 152.522 Td
(xorl %ecx,%ecx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 138.349 Td
(mul %ecx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 124.176 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 110.003 Td
(What is this shellcode doing?  Well, it 0's out the %ecx register using the xor instruction, so we now know ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 95.829 Td
(that %ecx is 0.  Then it does a mul %ecx, which as we just learned, multiplies it's operand by the value in ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 81.656 Td
(%eax, and then proceeds to store the result of this multiplication in EDX:EAX.  So, regardless of %eax's ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 67.483 Td
(previous contents, %eax must now be 0.  However that's not all, %edx is 0'd now too, because, even though no ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 53.31 Td
(overflow occurs, it still overwrites the %edx register with the sign bit\(left-most bit\) of %eax.  Using this ) Tj
ET
endstream
endobj
9 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 8 0 R
>>
endobj
10 0 obj
<<
/Length 5421
>>
stream
BT
/F0 10 Tf
0 0 0 rg
28.346 804.491 Td
(technique we can zero out three registers in only three bytes, whereas by any other method\(that I know of\) it ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 790.318 Td
(would have taken at least six.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 776.144 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 761.971 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 747.798 Td
(The div instruction) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 733.625 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 719.451 Td
(Div is very similar to mul, in that it takes only one operand and implicitly divides the operand by the value ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 705.278 Td
(in %eax.  Also like, mul it stores the result of the divide in %eax.  Again, we will require the mathematical ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 691.105 Td
(side of our brains to figure out how we can take advantage of this instruction.  But first, let's think about ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 676.932 Td
(what is normally stored in the %eax register.  The %eax register holds the return value of functions and/or ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 662.759 Td
(syscalls.  Most syscalls that are used in shellcoding will return -1\(on failure\) or a positive value of some ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 648.585 Td
(kind, only rarely will they return 0\(though it does occur\).  So, if we know that after a syscall is performed,) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 634.412 Td
(%eax will have a non-zero value, and that  the instruction divl %eax will divide %eax by itself, and then ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 620.239 Td
(store the result in %eax, we can say that executing the divl %eax instruction after a syscall will put the ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 606.066 Td
(value 1 into %eax.  So...how is this applicable to shellcoding? Well, their is another important thing that ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 591.892 Td
(%eax is used for, and that is to pass the specific syscall that you would like to call to int $0x80.  It just ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 577.719 Td
(so happens that the syscall that corresponds to the value 1 is exit\(\).  Now for an example:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 563.546 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 549.373 Td
(       ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 535.199 Td
(xorl %ebx,%ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 521.026 Td
(mul %ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 506.853 Td
(push %edx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 492.68 Td
(pushl   $0x3268732f) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 478.507 Td
(pushl   $0x6e69622f) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 464.333 Td
(mov %esp, %ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 450.16 Td
(push %edx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 435.987 Td
(push %ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 421.814 Td
(mov %esp,%ecx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 407.64 Td
(movb $0xb, %al  #execve\(\) syscall, doesn't return at all unless it fails, in which case it returns -1) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 393.467 Td
(int $0x80) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 379.294 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 365.121 Td
(divl %eax  # -1 / -1 = 1) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 350.948 Td
(int $0x80) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 336.774 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 322.601 Td
(Now, we have a 3 byte exit function, where as before it was 5 bytes.  However, there is a catch, what if a ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 308.428 Td
(syscall does return 0?  Well in the odd situation in which that could happen, you could do many different ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 294.255 Td
(things, like inc %eax, dec %eax, not %eax anything that will make %eax non-zero.  Some people say that exit's ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 280.081 Td
(are not important in shellcode, because your code gets executed regardless of whether or not it exits cleanly.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 265.908 Td
( They are right too, if you really need to save 3 bytes to fit your shellcode in somewhere, the exit\(\) isn't ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 251.735 Td
(worth keeping.  However, when your code does finish, it will try to execute whatever was after your last ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 237.562 Td
(instruction, which will most likely produce a SIG ILL\(illegal instruction\) which is a rather odd error, and ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 223.388 Td
(will be logged by the system.  So, an exit\(\) simply adds an extra layer of stealth to your exploit, so that ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 209.215 Td
(even if it fails or you can't wipe all the logs, at least this part of your presence will be clear.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 195.042 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 180.869 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 166.696 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 152.522 Td
(Unlocking the power of leal) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 138.349 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 124.176 Td
(The leal instruction is an often neglected instruction in shellcode, even though it is quite useful.  Consider) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 110.003 Td
(this short piece of shellcode.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 95.829 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 81.656 Td
(xorl %ecx,%ecx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 67.483 Td
(leal 0x10\(%ecx\),%eax) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 53.31 Td
() Tj
ET
endstream
endobj
11 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 10 0 R
>>
endobj
12 0 obj
<<
/Length 3269
>>
stream
BT
/F0 10 Tf
0 0 0 rg
28.346 804.491 Td
(This will load the value 17 into eax, and clear all of the extraneous bits of eax.  This occurs because the ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 790.318 Td
(leal instruction loads a variable of the type long into it's desitination operand.  In it's normal usage, this) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 776.144 Td
(would load the address of a variable into a register, thus creating a pointer of sorts.  However, since ecx is) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 761.971 Td
(0'd and 0+17=17, we load the value 17 into eax instead of any kind of actual address.  In a normal shellcode ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 747.798 Td
(we would do something like this, to accomplish the same thing:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 733.625 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 719.451 Td
(xorl %eax,%eax) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 705.278 Td
(movb $0x10,%eax) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 691.105 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 676.932 Td
(I can hear you saying, but that shellcode is a byte shorter than the leal one, and you're quite right.  ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 662.759 Td
(However, in a real shellcode you may already have to 0 out a register like ecx\(or any other register\), so the ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 648.585 Td
(xorl instruction in the leal shellcode isn't counted.  Here's an example:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 634.412 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 620.239 Td
(xorl    %eax,%eax) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 606.066 Td
(xorl    %ebx,%ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 591.892 Td
(movb    $0x17,%al) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 577.719 Td
(int    $0x80) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 563.546 Td
(       ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 549.373 Td
(xorl %ebx,%ebx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 535.199 Td
(leal 0x17\(%ebx\),%al) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 521.026 Td
(int $0x80) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 506.853 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 492.68 Td
(Both of these shellcodes call setuid\(0\), but one does it in 7 bytes while the other does it in 8.  Again, I ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 478.507 Td
(hear you saying but that's only one byte it doesn't make that much of a difference, and you're right, here it ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 464.333 Td
(doesn't make much of a difference\(except for in shellcode-size pissing contests =p\), but when applied to much ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 450.16 Td
(larger shellcodes, which have many function calls and need to do things like this frequently, it can save ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 435.987 Td
(quite a bit of space.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 421.814 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 407.64 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 393.467 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 379.294 Td
(Conclusion) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 365.121 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 350.948 Td
(I hope you all learned something, and will go out and apply your knowledge to create smaller and better ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 336.774 Td
(shellcodes.  If you know who invented  the leal technique, please tell me and I will credit him/her.  ) Tj
ET
endstream
endobj
13 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 12 0 R
>>
endobj
14 0 obj
<<
/Type/Catalog
/Pages 2 0 R
>>
endobj
2 0 obj
<<
/Type/Pages
/Kids[
9 0 R
11 0 R
13 0 R
]
/Count 3
/Resources 3 0 R
>>
endobj
3 0 obj
<<
/ProcSet[/PDF/Text/ImageC]
/Font<<
/F0 7 0 R
>>
>>
endobj
xref
0 15
0000000000 65535 f
0000000009 00000 n
0000016819 00000 n
0000016907 00000 n
0000000168 00000 n
0000000168 00000 n
0000001113 00000 n
0000001256 00000 n
0000001421 00000 n
0000007690 00000 n
0000007784 00000 n
0000013257 00000 n
0000013353 00000 n
0000016674 00000 n
0000016770 00000 n
trailer
<<
/Size 15
/Root 14 0 R
/Info 1 0 R
/ID[(424044341ttdndhldgenuf)(424044341ttdndhldgenuf)]
>>
startxref
16976
%%EOF
