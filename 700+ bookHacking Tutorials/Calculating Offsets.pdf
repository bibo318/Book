%PDF-1.3
1 0 obj
<<
/CreationDate(D:20160204102504)
/Title()
/Author(PDFZilla)
/Keywords(PDFZilla,Zilla PDF)
/Producer(PDFZilla - Zilla TXT To PDF Converter)
>>
endobj
5 0 obj
[
750 750 278 278 355 556 556 889 667 190 333 333 389 584 278 333 
278 278 556 556 556 556 556 556 556 556 556 556 278 278 584 584 
584 556 1015 667 667 722 722 667 610 778 722 278 500 667 556 832 
722 778 667 778 722 667 610 722 667 944 667 667 610 278 278 278 
469 556 333 556 556 500 556 556 278 556 556 222 222 500 222 832 
556 556 556 556 333 500 278 556 500 722 500 500 500 334 260 334 
584 750 556 750 222 556 333 1000 556 556 333 1000 667 333 1000 750 
610 750 750 222 222 333 333 350 556 1000 333 1000 500 333 944 750 
500 667 278 333 556 556 556 556 260 556 333 736 370 556 584 333 
736 552 400 549 333 333 333 576 537 333 333 333 365 556 834 834 
834 610 667 667 667 667 667 667 1000 722 667 667 667 667 278 278 
278 278 722 722 778 778 778 778 778 584 778 722 722 722 722 667 
667 610 556 556 556 556 556 556 889 500 556 556 556 556 278 278 
278 278 556 556 556 556 556 556 556 549 610 556 556 556 556 500 
556 500 
]
endobj
6 0 obj
<<
/Type/FontDescriptor
/FontName/Arial
/Ascent 905
/Descent -212
/ItalicAngle 0
/CapHeight 905
/Flags 32
/FontBBox[0 0 0 0]
>>
endobj
7 0 obj
<<
/Type/Font
/Subtype/TrueType
/Name/F0
/BaseFont/Arial
/Encoding/WinAnsiEncoding
/FirstChar 30
/LastChar 255
/Widths 5 0 R
/FontDescriptor 6 0 R
>>
endobj
8 0 obj
<<
/Length 5820
>>
stream
BT
/F0 10 Tf
0 0 0 rg
28.346 804.491 Td
(--------------------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 790.318 Td
(----------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 776.144 Td
( ///////////*1000+ HACKING TRICKS & TUTORIALS - ebook By Mukesh Bhardwaj Blogger  - Paid Version - only @ ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 761.971 Td
(TekGyd | itechhacks | Mukeshtricks4u*///////) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 747.798 Td
(--------------------------------------------------------------------------------------------------------------) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 733.625 Td
(---------------------------------------------------------------------------------------------------- ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 719.451 Td
(Introduction) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 705.278 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 691.105 Td
(This tutorial is more of a tip than a tutorial. It just explains how to calculate offsets for jumps and calls ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 676.932 Td
(within the program you are patching.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 662.759 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 648.585 Td
(Types of Jumps/Calls) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 634.412 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 620.239 Td
(Here I will just describe the different types of jumps and calls which you will come across:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 606.066 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 591.892 Td
(Short Jumps) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 577.719 Td
(Short jumps be they conditional or unconditional jumps are 2 bytes long \(or 1 nibble if your Californian ;-\). ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 563.546 Td
(These are relative jumps taken from the first byte after the two bytes of the jump. Using short jumps you can ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 549.373 Td
(jump a maximum of 127 bytes forward and 128 bytes backwards.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 535.199 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 521.026 Td
(Long Jumps) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 506.853 Td
(Long jumps if they are relative are 6 bytes long for conditional jumps and are 5 bytes long for unconditional ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 492.68 Td
(jumps. For conditional jumps 2 bytes are used to identify that it is a long jump and what type of jump \(je, ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 478.507 Td
(jg, jns etc\) it is. The other 4 bytes are used to show how far away the target location is relative to the ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 464.333 Td
(first byte after the jump. In an unconditional jump only 1 byte is used to identify it as a long unconditional) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 450.16 Td
(jump and the other 4 are used to show it's target's relative position, as with the conditional jumps.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 435.987 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 421.814 Td
(Calls) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 407.64 Td
(There are two different types of calls which we will use. The normal type of call works the same as the long ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 393.467 Td
(jumps in that it is relative to it's current position. The other type gives a reference to a memory location, ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 379.294 Td
(register or stack position which holds the memory location it will call. The position held by the later is ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 365.121 Td
(direct e.g. the memory location referenced may contain 401036h which would be the exact position that you ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 350.948 Td
(would call, not relative to the position of the call. The size of these types of calls depends on any ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 336.774 Td
(calculations involved in the call i.e. you could do: 'call dword ptr [eax * edx + 2]'. Long jumps can also be ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 322.601 Td
(made using this method, but I didn't say that earlier as to avoid repetition.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 308.428 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 294.255 Td
(Tables) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 280.081 Td
(Here is a brief list of all the different types of jumps/calls and their appropriate op-codes. Where different) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 265.908 Td
(jumps have the same Op-Codes I have grouped them:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 251.735 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 237.562 Td
(Jump Description Short Op-Code Long Op-Code) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 223.388 Td
(call procedure call E8xxxxxxxx N/A) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 209.215 Td
(jmp u nconditional jump EBxx E9xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 195.042 Td
(ja/jnbe jump if above 77xx 0F87xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 180.869 Td
(jae/jnb/jnc jump if above or equal 73xx 0F83xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 166.696 Td
(jb/jc/jnae jump if below 72xx 0F82xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 152.522 Td
(jbe/jna jump if below or equal 76xx 0F86xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 138.349 Td
(jcxz/jecxz jump if cx/ecx equals zero E3xx N/A) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 124.176 Td
(je/jz jump if equal/zero 74xx 0F84xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 110.003 Td
(jne/jnz jump if not equal/zero 75xx 0F85xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 95.829 Td
(jg/jnle jump if greater 7Fxx 0F8Fxxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 81.656 Td
(jge/jnl jump if greater or equal 7Dxx 0F8Dxxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 67.483 Td
(jl/jnge jump if less 7Cxx 0F8Cxxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 53.31 Td
(jle/jng jump if less or equal 7Exx 0F8Exxxxxxxx) Tj
ET
endstream
endobj
9 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 8 0 R
>>
endobj
10 0 obj
<<
/Length 4971
>>
stream
BT
/F0 10 Tf
0 0 0 rg
28.346 804.491 Td
(jno jump if not overflow 71xx 0F81xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 790.318 Td
(jnp/jpo jump if no parity/parity odd 7Bxx 0F8Bxxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 776.144 Td
(jns jump if not signed 79xx 0F89xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 761.971 Td
(jo jump if overflow 70xx 0F80xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 747.798 Td
(jp/jpe jump if parity/parity even 7Axx 0F8Axxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 733.625 Td
(js jump if sign 78xx 0F88xxxxxxxx) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 719.451 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 705.278 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 691.105 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 676.932 Td
(Calculating Offsets \(finding in the xx's in table\)) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 662.759 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 648.585 Td
(You will need to be able to calculate offsets when you add jumps and make calls within and to the code you ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 634.412 Td
(have added. If you choose to do this by hand instead of using a tool then here are the basics:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 620.239 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 606.066 Td
(For jumps and calls further on in memory from your current position you take the address where you want to ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 591.892 Td
(jump/call and subtract from it the memory location of the next instruction after your call/jump i.e.:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 577.719 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 563.546 Td
(\(target mem address\) - \(mem location of next instruction after call/jump\)) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 549.373 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 535.199 Td
(Example) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 521.026 Td
(If we wanted to jump to 4020d0 and the next instruction *after* the jump is at location 401093 then we would ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 506.853 Td
(use the following calculation:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 492.68 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 478.507 Td
(4020d0 - 401093 = 103d) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 464.333 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 450.16 Td
(We then write the jump instruction in hex as e93d100000 where e9 is the hex op-code for a long relative jump ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 435.987 Td
(and 3d100000 is the result of our calculation expanded to dword size and reversed.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 421.814 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 407.64 Td
(For jumps and calls to locations *before* the current location in memory you take the address you want to ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 393.467 Td
(call/jump to and subtract it from the memory location of the next instruction after your call/jump, then ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 379.294 Td
(subtract 1 and finally perform a logical NOT on the result i.e.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 365.121 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 350.948 Td
(NOT\(mem address of next instruction - target mem address - 1\)) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 336.774 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 322.601 Td
(Example) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 308.428 Td
(If we wanted to call location 401184 and the address of the next instruction after the call is 402190 then we ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 294.255 Td
(do the following calculation:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 280.081 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 265.908 Td
(NOT\(402190 - 401184 - 1 \) = ffffeff4) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 251.735 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 237.562 Td
(We can then write our call instruction in hex as e8f4efffff where e8 is the hex op-code for relative call and ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 223.388 Td
(f4efffff is the result of the calculation in reverse order.) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 209.215 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 195.042 Td
(If you want to practice with different examples then the best way to do this is to use a disassembler like ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 180.869 Td
(WDASM which shows you the op-codes and try and work out the results yourself. Also as an end note you don't ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 166.696 Td
(have to perform these calculations if you have enough room to make your jump or call instruction into an ) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 152.522 Td
(absolute jump call by doing the following as represented in assembler:) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 138.349 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 124.176 Td
(mov eax, 4020d0) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 110.003 Td
(call eax \(or jmp eax\)) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 95.829 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 81.656 Td
(Final Notes) Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 67.483 Td
() Tj
ET
BT
/F0 10 Tf
0 0 0 rg
28.346 53.31 Td
(Make life easier and use a program to do this ;-\)) Tj
ET
endstream
endobj
11 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 10 0 R
>>
endobj
12 0 obj
<<
/Length 0
>>
stream
endstream
endobj
13 0 obj
<<
/Type/Page
/Parent 2 0 R
/MediaBox[ 0 0 595.276 841.89 ]
/Contents 12 0 R
>>
endobj
14 0 obj
<<
/Type/Catalog
/Pages 2 0 R
>>
endobj
2 0 obj
<<
/Type/Pages
/Kids[
9 0 R
11 0 R
13 0 R
]
/Count 3
/Resources 3 0 R
>>
endobj
3 0 obj
<<
/ProcSet[/PDF/Text/ImageC]
/Font<<
/F0 7 0 R
>>
>>
endobj
xref
0 15
0000000000 65535 f
0000000009 00000 n
0000012699 00000 n
0000012787 00000 n
0000000168 00000 n
0000000168 00000 n
0000001113 00000 n
0000001256 00000 n
0000001421 00000 n
0000007292 00000 n
0000007386 00000 n
0000012409 00000 n
0000012505 00000 n
0000012554 00000 n
0000012650 00000 n
trailer
<<
/Size 15
/Root 14 0 R
/Info 1 0 R
/ID[(424044341ttautgfef)(424044341ttautgfef)]
>>
startxref
12856
%%EOF
